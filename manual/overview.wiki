= Js_of_ocaml =

== Overview ==

Js_of_ocaml is a compiler from OCaml bytecode programs to JavaScript.
It makes it possible to run pure OCaml programs in JavaScript environment
like browsers and Node.js. It is easy to install as it works with an
existing installation of OCaml, with no need to recompile any library.
It comes with bindings for a large part of the browser APIs.
According to our benchmarks, the generated programs
<<a_manual chapter="performances" |runs typically faster>> than with
the OCaml bytecode interpreter.  We believe this compiler will prove
much easier to maintain than a retargeted OCaml compiler, as the
bytecode provides a very stable API.

Js_of_ocaml is composed of multiple packages:
  * js_of_ocaml-compiler, the compiler.
  * js_of_ocaml-ppx, a ppx syntax extension.
  * js_of_ocaml, the base library.
  * js_of_ocaml-ppx_deriving_json
  * js_of_ocaml-lwt, lwt support.
  * js_of_ocaml-tyxml, tyxml support.
  * js_of_ocaml-toplevel, lib and tools to build an ocaml toplevel to
    javascript.

Note: All code examples in this manual use Js_of_ocaml's ppx syntax.
It is, however, possible to use Js_of_ocaml purely as a compiler
while using a different package (e.g. gen_js_api, brr) to
provide bindings to the browser APIs.

== Installation

The easiest way to install js_of_ocaml is to use opam.
{{{opam install js_of_ocaml js_of_ocaml-ppx js_of_ocaml-lwt}}}

For alternatives, see <<a_manual chapter="install" |Install>>.

== Usage ==

  Your program must first be compiled using the OCaml bytecode
  compiler {{{ocamlc}}}.  JavaScript bindings are provided by the
  {{{js_of_ocaml}}} package and the syntax extension by the
  {{{js_of_ocaml-ppx}}} package
{{{
      ocamlfind ocamlc -package js_of_ocaml -package js_of_ocaml-ppx \
          -linkpkg -o cubes.byte cubes.ml
}}}
  Then, run the {{{js_of_ocaml}}} compiler to produce JavaScript code:
{{{
      js_of_ocaml cubes.byte
}}}

JavaScript files generated by js_of_ocaml are UTF-8 encoded.

=== with ocamlbuild and oasis ===
  Js_of_ocaml also provide an ocamlbuild plugin.
  See [[https://github.com/ocsigen/js_of_ocaml-ocamlbuild/blob/master/ocamlbuild_js_of_ocaml.mli|js_of_ocaml-ocamlbuild>>.

=== with dune ===
  Dune has native support for js_of_ocaml.
  It support both standard and separate compilation of javascript
  files. See https://dune.readthedocs.io/en/latest/jsoo.html

=== toplevel ===
You can find an OCaml toplevel running in the browser <<a_file src="toplevel/index.html" |here>>.

== Supported features ==

Most of the OCaml standard library is supported. However,
  * Most of Sys module is not supported.

Extra libraries distributed with Ocaml (such as Thread) are not
supported in general. However,
  * Bigarray: bigarray are supported using Typed Arrays
  * Num: supported
  * Str: supported
  * Graphics: partially supported using canvas (see also js_of_ocaml-lwt.graphics)
  * Unix: time related functions are supported

Tail call is not optimized in general. However, mutually recursive
functions are optimized:
  * self recursive functions (when the tail calls are the function itself) are
    compiled using a loop.
  * trampolines are used otherwise.
<<a_manual chapter="tailcall" |More about tail call optimization>>.

Effect handlers are fully supported with the
{{{--enable=effects}}} flag. Effect support is disabled by
default for now since effects are not widely used at the moment and the
generated code can be slower, larger and less readable. See the dedicated
manual section about effects for details.

Data representation differs from the usual one. Most notably,
integers are 32 bits (rather than 31 bits or 63 bits), which is their
natural size in JavaScript, and floats are not boxed.  As a
consequence, marshalling, polymorphic comparison, and hashing
functions can yield results different from usual:
  * marshalling floats might generate different output. Such output should not be
    unmarshalled using the standard ocaml runtime (native or bytecode);
  * the polymorphic hash function will not give the same results on
    datastructures containing floats;
  * these functions may be more prone to stack overflow.

Note that float rounding is slightly different between native and
JavaScript.  Both round to nearest but resolve the tie
differently. Javascript resolves the tie away from zero while libc
resolves the tee to even.
