= Building a toplevel

First, initialize the toplevel using <<a_api subproject="js_of_ocaml-toplevel"|val Js_of_ocaml_toplevel.JsooTop.initialize>>.

Then, build your bytecode program with debug enabled ({{{-g}}}) and linkall ({{{-linkall}}}). Link in all the libraries you want accessible in the final toplevel.

Finally, compile your toplevel to JavaScript passing the {{{--toplevel}}} flag to the js_of_ocaml compiler.

If you want to limit the set of modules available in the toplevel, you can explicitly pass a list of compilation units that should be accessible using the {{{--export FILE}}} flag.
{{{FILE}}} must contain names of compilation units to export, one per line. The {{{jsoo_listunits}}} tool, provided by the {{{js_of_ocaml-toplevel}}} opam package, can be used to generate this list from a set of findlib libraries.

For example, the following command will create a file containing all compilation unit names provided by the findlib libraries {{{stdlib}}} and {{{str}}}:
{{{
jsoo_listunits -o units.txt stdlib str
}}}

= Using the Dynlink library

OCaml supports dynlink of bytecode files using the {{{dynlink}}} library. To use it when compiled to JavaScript:

# Link {{{js_of_ocaml-compiler.dynlink}}} to initialize dynlink support (initialization is automatic via side-effect)
# Build your bytecode program with debug enabled ({{{-g}}}) and linkall ({{{-linkall}}})
# Compile your program to JavaScript passing the {{{--dynlink}}} flag

==@@id="example"@@ Example

{{{
# main.ml
let () = Dynlink.loadfile "./plugin.cmo"

# Compiling main program
ocamlfind ocamlc -linkpkg -package dynlink -package js_of_ocaml-compiler.dynlink main.ml -o main.bc
js_of_ocaml main.bc --dynlink

# Compiling plugin
ocamlfind ocamlc -c plugin.ml

# Test
node ./main.js
}}}
