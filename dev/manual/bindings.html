<html><head><title> How to bind a JS library for OCaml</title><meta charset="utf8"/><meta content="width=device-width, initial-scale=1" name="viewport"/><link rel="stylesheet" href="https://ocsigen.org/css/style.css"/><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.9.0/themes/prism.min.css"/><script type="application/javascript" src="https://ocsigen.org/js/client.js">
//<![CDATA[

//]]>
</script><script type="application/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.9.0/components/prism-core.min.js">
//<![CDATA[

//]]>
</script><script type="application/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.9.0/components/prism-ocaml.min.js">
//<![CDATA[

//]]>
</script><script type="application/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.9.0/components/prism-clike.min.js">
//<![CDATA[

//]]>
</script><script type="application/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.9.0/components/prism-reason.min.js">
//<![CDATA[

//]]>
</script><script type="application/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.9.0/components/prism-javascript.min.js">
//<![CDATA[

//]]>
</script></head><body class="bindings js_of_ocaml"><div class="project-page"><div class="page-header"><p class="logo-ocsigen"><a href=".././../../" class="ocsimore_phrasing_link"><img src=".././../../img/ocsigen-white.svg" alt="Ocsigen"/></a>
</p><p class="logo-subproject">Js_of_ocaml</p><div class="mainmenu"><p class="mainmenu-home"><a href=".././../../" class="ocsimore_phrasing_link">Home</a></p><p class="mainmenu-doc"><a href=".././../../tuto/" class="ocsimore_phrasing_link">Doc</a></p><p><a href=".././../../eliom/" class="ocsimore_phrasing_link">Eliom</a></p><p class="mainmenu-current"><a href=".././../../js_of_ocaml/" class="ocsimore_phrasing_link">Js_of_ocaml</a></p><p><a href=".././../../ocsigenserver/" class="ocsimore_phrasing_link">Server</a></p><p><a href=".././../../lwt/" class="ocsimore_phrasing_link">Lwt</a></p><p><a href=".././../../tyxml/" class="ocsimore_phrasing_link">Tyxml</a></p><p><a href=".././../../ocsigen-start/" class="ocsimore_phrasing_link">Start</a></p></div><form id="googlesearch" action="https://google.com/search"><input name="q" id="gsearch-box" placeholder="Search using Google"/><label for="gsearch-box"><img src="/img/search.svg" alt="" id="gsearch-icon"/></label><input type="submit" id="gsearch-submit" onclick="document.getElementById('gsearch-box').value += ' site:ocsigen.org';"/></form><aside class="how-drawer"><input id="how-drawer-toggle" type="checkbox"/><label for="how-drawer-toggle" id="how-drawer-label"><span class="how-drawer-icon"></span></label><nav class="how-drawer-content"><ul class="drawermainmenu"><li class="drawermainmenu-home"><a href=".././../../" class="ocsimore_phrasing_link">Home</a>
</li><li class="drawermainmenu-doc"><a href=".././../../tuto/" class="ocsimore_phrasing_link">Doc</a>
</li><li class="drawermainmenu-project"><a href=".././../../eliom/" class="ocsimore_phrasing_link">Eliom</a>
</li><li class="drawermainmenu-project"><a href=".././../../js_of_ocaml/" class="ocsimore_phrasing_link">Js_of_ocaml</a>
</li><li class="drawermainmenu-project"><a href=".././../../ocsigenserver/" class="ocsimore_phrasing_link">Server</a>
</li><li class="drawermainmenu-project"><a href=".././../../lwt/" class="ocsimore_phrasing_link">Lwt</a>
</li><li class="drawermainmenu-project"><a href=".././../../tyxml/" class="ocsimore_phrasing_link">Tyxml</a>
</li><li class="drawermainmenu-project"><a href=".././../../ocsigen-toolkit/" class="ocsimore_phrasing_link">Toolkit</a>
</li><li class="drawermainmenu-project"><a href=".././../../ocsigen-start/" class="ocsimore_phrasing_link">Start</a>
</li><li class="drawermainmenu-project"><a href=".././../../ocsipersist/" class="ocsimore_phrasing_link">Ocsipersist</a>
</li><li class="drawermainmenu-project"><a href=".././../../html_of_wiki/" class="ocsimore_phrasing_link">html_of_wiki</a>
</li><li class="drawermainmenu-project"><a href=".././../../ocsimore/" class="ocsimore_phrasing_link">Ocsimore (<em>deprecated</em>)</a>
</li><li class="drawermainmenu-page"><a href=".././../../projects" class="ocsimore_phrasing_link">Other projects</a>
</li><li class="drawermainmenu-page"><a href=".././../../papers" class="ocsimore_phrasing_link">Research papers</a>
</li><li class="drawermainmenu-page"><a href=".././../../credits" class="ocsimore_phrasing_link">Who does Ocsigen?</a>
</li><li class="drawermainmenu-page"><a href=".././../../contributing" class="ocsimore_phrasing_link">Contributing</a>
</li><li class="drawermainmenu-page"><a href=".././../../blog" class="ocsimore_phrasing_link">Blog</a>
</li><li class="drawermainmenu-page"><a href=".././../../install" class="ocsimore_phrasing_link">Installation</a>
</li><li class="drawermainmenu-page"><a href="https://github.com/ocsigen" class="ocsimore_phrasing_link">Source code</a>
</li></ul><nav class="how-doctree"><h2>Getting Started</h2><h3><a href="overview" class="ocsimore_phrasing_link">Overview</a></h3><h3><a href="quickstart" class="ocsimore_phrasing_link">Quick Start</a></h3><h3><a href="install" class="ocsimore_phrasing_link">Installation</a></h3><h2>Programming Guide</h2><h3><a href="library" class="ocsimore_phrasing_link">Library overview</a></h3><h3><a href="bindings" class="ocsimore_phrasing_link">Binding a JS library</a></h3><h3><a href="rev-bindings" class="ocsimore_phrasing_link">Export OCaml code to JavaScript</a></h3><h3><a href="errors" class="ocsimore_phrasing_link">Error handling</a></h3><h3><span><a href=".././api/js_of_ocaml/">API</a></span></h3><h2>Syntaxes</h2><h3><a href="ppx" class="ocsimore_phrasing_link">Ppx syntax extension</a></h3><h3><a href="ppx-deriving" class="ocsimore_phrasing_link">Ppx deriving json</a></h3><h2>Lwt Support</h2><h3><a href="lwt" class="ocsimore_phrasing_link">Lwt support</a></h3><h3><span><a href=".././api/js_of_ocaml-lwt/">API</a></span></h3><h2>Compiler</h2><h3><a href="options" class="ocsimore_phrasing_link">Command line options</a></h3><h3><a href="linker" class="ocsimore_phrasing_link">Linking JavaScript code</a></h3><h3><a href="compilation-modes" class="ocsimore_phrasing_link">Compilation modes</a></h3><h3><a href="tailcall" class="ocsimore_phrasing_link">Tailcall optimization</a></h3><h3><a href="effects" class="ocsimore_phrasing_link">Effect handlers</a></h3><h2>Wasm_of_ocaml</h2><h3><a href="wasm_overview" class="ocsimore_phrasing_link">Overview</a></h3><h3><a href="wasm_runtime" class="ocsimore_phrasing_link">Writing Wasm primitives</a></h3><h2>How-to Guides</h2><h3><a href="build-toplevel" class="ocsimore_phrasing_link">Build a toplevel or use Dynlink</a></h3><h3><a href="debug" class="ocsimore_phrasing_link">Debug a program</a></h3><h3><a href="performances" class="ocsimore_phrasing_link">Performances</a></h3><h3><a href="contribute" class="ocsimore_phrasing_link">Contribute</a></h3><h2>Examples</h2><h3><span><a href=".././manual/files/toplevel/index.html">OCaml toplevel in the browser</a></span></h3><h3><span><a href=".././manual/files/planet/index.html">Animated 3D view of the Earth</a></span></h3><h3><span><a href=".././manual/files/graph_viewer/index.html">Graph viewer</a></span></h3><h3><span><a href=".././manual/files/boulderdash/index.html">Boulder Dash game</a></span></h3><h3><span><a href=".././manual/files/wiki/index.html">Realtime wiki editor</a></span></h3><h3><span><a href=".././manual/files/webgl/index.html">WebGL demo</a></span></h3><h3><span><a href=".././manual/files/minesweeper/index.html">Minesweeper game</a></span></h3><h3><span><a href=".././manual/files/hyperbolic/index.html">Hyperbolic tree viewer</a></span></h3><h3><span><a href=".././manual/files/cubes/index.html">Random walk on lozenge tilings</a></span></h3></nav></nav></aside></div><p class="reasonwarning">Warning: Reason support is experimental.
We are looking for beta-tester and contributors.
</p><button id="reason">Switch to </button><div class="twocols"><nav class="leftcol">Version <select class="how-versions" onchange="location = this.value;"><option value=".././../dev/manual/bindings" selected="selected">dev</option><option value=".././../6.2.0/manual/bindings">6.2.0</option><option value=".././../6.1.0/manual/bindings">6.1.0</option><option value=".././../6.0.1/manual/bindings">6.0.1</option><option value=".././../5.9.1/manual/bindings">5.9.1</option><option value=".././../5.8.2/manual/bindings">5.8.2</option><option value=".././../5.7.2/manual/bindings">5.7.2</option><option value=".././../5.6.0/manual/bindings">5.6.0</option><option value=".././../5.5.2/manual/bindings">5.5.2</option><option value=".././../5.4.0/manual/bindings">5.4.0</option><option value=".././../5.3.0/manual/bindings">5.3.0</option><option value=".././../5.2.0/manual/bindings">5.2.0</option><option value=".././../5.1.0/manual/bindings">5.1.0</option><option value=".././../5.0.1/manual/bindings">5.0.1</option><option value=".././../4.1.0/manual/bindings">4.1.0</option><option value=".././../4.0.0/manual/bindings">4.0.0</option><option value=".././../3.11.0/manual/bindings">3.11.0</option><option value=".././../3.10.0/manual/bindings">3.10.0</option><option value=".././../3.9.0/manual/bindings">3.9.0</option><option value=".././../3.8.0/manual/bindings">3.8.0</option><option value=".././../3.7.0/manual/bindings">3.7.0</option><option value=".././../3.6.0/manual/bindings">3.6.0</option><option value=".././../3.5.1/manual/bindings">3.5.1</option></select><nav class="how-doctree"><h2>Getting Started</h2><h3><a href="overview" class="ocsimore_phrasing_link">Overview</a></h3><h3><a href="quickstart" class="ocsimore_phrasing_link">Quick Start</a></h3><h3><a href="install" class="ocsimore_phrasing_link">Installation</a></h3><h2>Programming Guide</h2><h3><a href="library" class="ocsimore_phrasing_link">Library overview</a></h3><h3><a href="bindings" class="ocsimore_phrasing_link">Binding a JS library</a></h3><h3><a href="rev-bindings" class="ocsimore_phrasing_link">Export OCaml code to JavaScript</a></h3><h3><a href="errors" class="ocsimore_phrasing_link">Error handling</a></h3><h3><span><a href=".././api/js_of_ocaml/">API</a></span></h3><h2>Syntaxes</h2><h3><a href="ppx" class="ocsimore_phrasing_link">Ppx syntax extension</a></h3><h3><a href="ppx-deriving" class="ocsimore_phrasing_link">Ppx deriving json</a></h3><h2>Lwt Support</h2><h3><a href="lwt" class="ocsimore_phrasing_link">Lwt support</a></h3><h3><span><a href=".././api/js_of_ocaml-lwt/">API</a></span></h3><h2>Compiler</h2><h3><a href="options" class="ocsimore_phrasing_link">Command line options</a></h3><h3><a href="linker" class="ocsimore_phrasing_link">Linking JavaScript code</a></h3><h3><a href="compilation-modes" class="ocsimore_phrasing_link">Compilation modes</a></h3><h3><a href="tailcall" class="ocsimore_phrasing_link">Tailcall optimization</a></h3><h3><a href="effects" class="ocsimore_phrasing_link">Effect handlers</a></h3><h2>Wasm_of_ocaml</h2><h3><a href="wasm_overview" class="ocsimore_phrasing_link">Overview</a></h3><h3><a href="wasm_runtime" class="ocsimore_phrasing_link">Writing Wasm primitives</a></h3><h2>How-to Guides</h2><h3><a href="build-toplevel" class="ocsimore_phrasing_link">Build a toplevel or use Dynlink</a></h3><h3><a href="debug" class="ocsimore_phrasing_link">Debug a program</a></h3><h3><a href="performances" class="ocsimore_phrasing_link">Performances</a></h3><h3><a href="contribute" class="ocsimore_phrasing_link">Contribute</a></h3><h2>Examples</h2><h3><span><a href=".././manual/files/toplevel/index.html">OCaml toplevel in the browser</a></span></h3><h3><span><a href=".././manual/files/planet/index.html">Animated 3D view of the Earth</a></span></h3><h3><span><a href=".././manual/files/graph_viewer/index.html">Graph viewer</a></span></h3><h3><span><a href=".././manual/files/boulderdash/index.html">Boulder Dash game</a></span></h3><h3><span><a href=".././manual/files/wiki/index.html">Realtime wiki editor</a></span></h3><h3><span><a href=".././manual/files/webgl/index.html">WebGL demo</a></span></h3><h3><span><a href=".././manual/files/minesweeper/index.html">Minesweeper game</a></span></h3><h3><span><a href=".././manual/files/hyperbolic/index.html">Hyperbolic tree viewer</a></span></h3><h3><span><a href=".././manual/files/cubes/index.html">Random walk on lozenge tilings</a></span></h3></nav></nav><article class="rightcol"><h1> How to bind a JS library for OCaml</h1><h2 id="accessing-properties"> Accessing JavaScript properties <a class="backref" href="#accessing-properties">&#182;</a></h2><h3> Global variables</h3><p>Global JavaScript variables are properties of the global object. Use
<span><a href=".././api/js_of_ocaml/Js_of_ocaml/Js/Unsafe/#val-global">Js_of_ocaml.Js.Unsafe.global</a></span> to access them (<span class="teletype">window</span> in browsers,
<span class="teletype">globalThis</span> in Node.js):
</p><pre class=""><code class="language-ocaml translatable">(* Access document *)
let doc : Dom_html.document Js.t = Js.Unsafe.global##.document

(* Read and write a custom global *)
let get_config () : config Js.t = Js.Unsafe.global##.myAppConfig
let set_config (x : config Js.t) = Js.Unsafe.global##.myAppConfig := x</code></pre><p>You can also use <span><a href=".././api/js_of_ocaml/Js_of_ocaml/Js/Unsafe/#val-js_expr">Js_of_ocaml.Js.Unsafe.js_expr</a></span> for any JavaScript expression:
</p><pre class=""><code class="language-ocaml translatable">let v = (Js.Unsafe.js_expr &quot;window&quot;)##.document</code></pre><p>Be careful: both <span><a href=".././api/js_of_ocaml/Js_of_ocaml/Js/Unsafe/#val-global">Js_of_ocaml.Js.Unsafe.global</a></span> and <span><a href=".././api/js_of_ocaml/Js_of_ocaml/Js/Unsafe/#val-js_expr">Js_of_ocaml.Js.Unsafe.js_expr</a></span> are untyped.
Verify the library documentation before writing type annotations.
</p><h3> Untyped property access</h3><p>When a property is missing from the OCaml interface (e.g., dynamically added
by a library), use <span><a href=".././api/js_of_ocaml/Js_of_ocaml/Js/Unsafe/#val-coerce">Js_of_ocaml.Js.Unsafe.coerce</a></span> for untyped access:
</p><pre class=""><code class="language-ocaml translatable">(* Read a property *)
let value = (Js.Unsafe.coerce obj)##.someProp

(* Write a property *)
(Js.Unsafe.coerce obj)##.someProp := v</code></pre><p>For type-safe access, define a class type for the extended object or wrap
the unsafe access in getter/setter functions.
</p><h2 id="binding-object"> Binding a JS object <a class="backref" href="#binding-object">&#182;</a></h2><p>Use OCaml class types to describe the shape of JavaScript objects. Each
<span class="teletype">method</span> declaration represents either a property or a method of the JS
object.
</p><h3> Property types</h3><table><tr><th> Type </th><th> Access </th><th> OCaml usage </th></tr><tr><td> <span class="teletype">t readonly_prop</span> </td><td> read only </td><td> <span class="teletype">obj##.prop</span> </td></tr><tr><td> <span class="teletype">t writeonly_prop</span> </td><td> write only </td><td> <span class="teletype">obj##.prop := v</span> </td></tr><tr><td> <span class="teletype">t prop</span> </td><td> read/write </td><td> both </td></tr><tr><td> <span class="teletype">t1 -&gt; t2 -&gt; ... -&gt; t meth</span> </td><td> method </td><td> <span class="teletype">obj##meth arg1 arg2</span> </td></tr><tr><td> <span class="teletype">t optdef_prop</span> </td><td> optional read </td><td> <span class="teletype">obj##.prop</span> returns <span class="teletype">t Optdef.t</span> </td></tr></table><h3> Example</h3><p>Given a JavaScript object:
</p><pre class="manually-translated"><code class="language-javascript">{
  name: &quot;example&quot;,           // read-only string
  count: 42,                 // read-write number
  greet: function(x) { ... } // method
}</code></pre><p>Bind it as:
</p><pre class=""><code class="language-ocaml translatable">class type myObj = object
  method name : Js.js_string Js.t Js.readonly_prop
  method count : int Js.prop
  method greet : Js.js_string Js.t -&gt; unit Js.meth
end</code></pre><h3> Method name mangling</h3><p>OCaml method names are transformed to JavaScript names using underscore
conventions. When accessing a field of an object, the name given in OCaml
is transformed by:
</p><ol><li> Removing a leading underscore (if present)
</li><li> Removing all characters starting from the last underscore
</li></ol><p>This enables:
- <strong>Capitalized names</strong>: Use <span class="teletype">_Foo</span> to refer to JavaScript's <span class="teletype">Foo</span>
- <strong>Reserved words</strong>: Use <span class="teletype">_type</span> to refer to JavaScript's <span class="teletype">type</span>
- <strong>Method overloading</strong>: Use <span class="teletype">foo_int</span> and <span class="teletype">foo_string</span> for the same <span class="teletype">foo</span> method
</p><h4> Examples</h4><pre class=""><code class="language-ocaml translatable">class type canvas = object
  (* All three refer to the same JS method: drawImage *)
  method drawImage :
      imageElement Js.t -&gt; int -&gt; int -&gt; unit Js.meth
  method drawImage_withSize :
      imageElement Js.t -&gt; int -&gt; int -&gt; int -&gt; int -&gt; unit Js.meth
  method drawImage_fromCanvas :
      canvasElement Js.t -&gt; int -&gt; int -&gt; unit Js.meth
end</code></pre><h4> Full naming rules</h4><pre class=""><code class="language-ocaml translatable">class type example = object
  (* All of these refer to JS field [meth] *)
  method meth : ..
  method meth_int : ..
  method _meth_ : ..
  method _meth_aa : ..

  (* All of these refer to JS field [meth_a] *)
  method meth_a_int : ..
  method _meth_a_ : ..
  method _meth_a_b : ..

  (* Refer to [Meth] (capitalized) *)
  method _Meth : ..

  (* Refer to [_meth] (leading underscore in JS) *)
  method __meth : ..

  (* Refer to [_] *)
  method __ : ..
end</code></pre><h3> Binding constants from a class</h3><p>For JavaScript constants like <span class="teletype">SomeLib.SomeClass.VALUE_A</span>:
</p><pre class=""><code class="language-ocaml translatable">(* Type definition *)
class type someClass = object
  method _VALUE_A : int Js.readonly_prop
  method _VALUE_B : int Js.readonly_prop
end

(* Get the class object *)
let someClass : someClass Js.t =
  (Js.Unsafe.js_expr &quot;SomeLib&quot;)##._SomeClass

(* Access constants *)
let value_a = someClass##._VALUE_A</code></pre><h2 id="type-conversions"> Type conversions <a class="backref" href="#type-conversions">&#182;</a></h2><p>OCaml and JavaScript have different representations for basic types. Use
these functions to convert between them.
</p><h3> Strings</h3><p>OCaml strings and JavaScript strings have different encodings. Use <span><a href=".././api/js_of_ocaml/Js_of_ocaml/Js/#val-string">Js_of_ocaml.Js.string</a></span>
and <span><a href=".././api/js_of_ocaml/Js_of_ocaml/Js/#val-to_string">Js_of_ocaml.Js.to_string</a></span> for UTF-8 encoded OCaml strings:
</p><pre class=""><code class="language-ocaml translatable">(* OCaml string -&gt; JS string *)
let js_str : Js.js_string Js.t = Js.string &quot;Hello&quot;

(* JS string -&gt; OCaml string *)
let ocaml_str : string = Js.to_string js_str</code></pre><p>For binary data (bytes 0-255), use <span><a href=".././api/js_of_ocaml/Js_of_ocaml/Js/#val-bytestring">Js_of_ocaml.Js.bytestring</a></span> and <span><a href=".././api/js_of_ocaml/Js_of_ocaml/Js/#val-to_bytestring">Js_of_ocaml.Js.to_bytestring</a></span>:
</p><pre class=""><code class="language-ocaml translatable">let js_bytes = Js.bytestring &quot;\x00\x01\x02&quot;
let ocaml_bytes = Js.to_bytestring js_bytes</code></pre><h3> Booleans</h3><p>JavaScript booleans are not OCaml booleans. Use <span><a href=".././api/js_of_ocaml/Js_of_ocaml/Js/#val-bool">Js_of_ocaml.Js.bool</a></span> and <span><a href=".././api/js_of_ocaml/Js_of_ocaml/Js/#val-to_bool">Js_of_ocaml.Js.to_bool</a></span>:
</p><pre class=""><code class="language-ocaml translatable">let js_true : bool Js.t = Js._true        (* or Js.bool true *)
let js_false : bool Js.t = Js._false      (* or Js.bool false *)
let ocaml_bool : bool = Js.to_bool js_true</code></pre><h3> Numbers</h3><p>OCaml integers can be used directly. For floats, use <span><a href=".././api/js_of_ocaml/Js_of_ocaml/Js/#val-number_of_float">Js_of_ocaml.Js.number_of_float</a></span> and
<span><a href=".././api/js_of_ocaml/Js_of_ocaml/Js/#val-float_of_number">Js_of_ocaml.Js.float_of_number</a></span>:
</p><pre class=""><code class="language-ocaml translatable">(* Integers work directly *)
let count : int = obj##.count

(* Floats need conversion *)
let js_num : Js.number Js.t = Js.number_of_float 3.14
let ocaml_float : float = Js.float_of_number js_num</code></pre><h3> Arrays</h3><pre class=""><code class="language-ocaml translatable">(* OCaml array -&gt; JS array *)
let js_arr : int Js.js_array Js.t = Js.array [| 1; 2; 3 |]

(* JS array -&gt; OCaml array *)
let ocaml_arr : int array = Js.to_array js_arr</code></pre><h3> Summary table</h3><table><tr><th> OCaml type </th><th> JS type </th><th> OCaml → JS </th><th> JS → OCaml </th></tr><tr><td> <span class="teletype">string</span> </td><td> String </td><td> <span class="teletype">Js.string</span> </td><td> <span class="teletype">Js.to_string</span> </td></tr><tr><td> <span class="teletype">string</span> (bytes) </td><td> String </td><td> <span class="teletype">Js.bytestring</span> </td><td> <span class="teletype">Js.to_bytestring</span> </td></tr><tr><td> <span class="teletype">bool</span> </td><td> Boolean </td><td> <span class="teletype">Js.bool</span> </td><td> <span class="teletype">Js.to_bool</span> </td></tr><tr><td> <span class="teletype">int</span> </td><td> Number </td><td> (direct) </td><td> (direct) </td></tr><tr><td> <span class="teletype">float</span> </td><td> Number </td><td> <span class="teletype">Js.float</span> </td><td> <span class="teletype">Js.to_float</span> </td></tr><tr><td> <span class="teletype">'a array</span> </td><td> Array </td><td> <span class="teletype">Js.array</span> </td><td> <span class="teletype">Js.to_array</span> </td></tr></table><h2 id="null-undefined"> Handling null and undefined <a class="backref" href="#null-undefined">&#182;</a></h2><p>JavaScript has two &quot;missing value&quot; types: <span class="teletype">null</span> and <span class="teletype">undefined</span>.
Js_of_ocaml represents these with distinct types.
</p><h3> <span><a href=".././api/js_of_ocaml/Js_of_ocaml/Js/Opt/#module-Opt">Js_of_ocaml.Js.Opt</a></span> for nullable values (<span class="teletype">null</span>)</h3><p>Use <span><a href=".././api/js_of_ocaml/Js_of_ocaml/Js/Opt/#module-Opt">Js_of_ocaml.Js.Opt</a></span> for values that may be <span class="teletype">null</span> (e.g., DOM methods that
return <span class="teletype">null</span> when an element is not found):
</p><pre class=""><code class="language-ocaml translatable">(* Check if null *)
let is_present = Js.Opt.test value

(* Convert to OCaml option *)
let opt : element Js.t option = Js.Opt.to_option value

(* Handle both cases *)
let result = Js.Opt.case value
  (fun () -&gt; (* null *) &quot;not found&quot;)
  (fun v -&gt; (* has value *) process v)

(* Get value or raise exception *)
let v = Js.Opt.get value (fun () -&gt; failwith &quot;was null&quot;)

(* Create nullable values *)
let some_val : element Js.t Js.opt = Js.some element
let null_val : element Js.t Js.opt = Js.null</code></pre><h3> <span><a href=".././api/js_of_ocaml/Js_of_ocaml/Js/Optdef/#module-Optdef">Js_of_ocaml.Js.Optdef</a></span> for optional values (<span class="teletype">undefined</span>)</h3><p>Use <span><a href=".././api/js_of_ocaml/Js_of_ocaml/Js/Optdef/#module-Optdef">Js_of_ocaml.Js.Optdef</a></span> for values that may be <span class="teletype">undefined</span> (e.g., optional
object properties, array access beyond bounds):
</p><pre class=""><code class="language-ocaml translatable">(* Check if defined *)
let is_defined = Js.Optdef.test value

(* Convert to OCaml option *)
let opt : config Js.t option = Js.Optdef.to_option value

(* Handle both cases *)
let result = Js.Optdef.case value
  (fun () -&gt; (* undefined *) default_config)
  (fun v -&gt; (* defined *) v)

(* Create optdef values *)
let def_val : int Js.optdef = Js.def 42
let undef_val : int Js.optdef = Js.undefined</code></pre><h3> When to use which</h3><table><tr><th> Scenario </th><th> Type </th><th> Example </th></tr><tr><td> DOM lookup </td><td> <span class="teletype">Js.Opt</span> </td><td> <span class="teletype">getElementById</span> returns <span class="teletype">null</span> if not found </td></tr><tr><td> Optional property </td><td> <span class="teletype">Js.Optdef</span> </td><td> Property may not exist on object </td></tr><tr><td> Array access </td><td> <span class="teletype">Js.Optdef</span> </td><td> <span><a href=".././api/js_of_ocaml/Js_of_ocaml/Js/#val-array_get">Js_of_ocaml.Js.array_get</a></span> returns <span class="teletype">undefined</span> for missing index </td></tr><tr><td> API returns null </td><td> <span class="teletype">Js.Opt</span> </td><td> Many DOM APIs use <span class="teletype">null</span> for &quot;no value&quot; </td></tr><tr><td> Feature detection </td><td> <span class="teletype">Js.Optdef</span> </td><td> Check if method/property exists </td></tr></table><h3> Combining with option types</h3><p>Both modules provide <span class="teletype">to_option</span> for idiomatic OCaml code:
</p><pre class=""><code class="language-ocaml translatable">let find_element id =
  Dom_html.getElementById_opt id
  |&gt; Js.Opt.to_option

let () =
  match find_element &quot;myId&quot; with
  | Some el -&gt; (* use element *)
  | None -&gt; (* not found *)</code></pre><h2 id="calling-functions"> Calling JS functions <a class="backref" href="#calling-functions">&#182;</a></h2><p>There are three ways to call JavaScript functions, depending on how <span class="teletype">this</span>
should be bound.
</p><h3> Standalone functions with <span class="teletype">fun_call</span></h3><p>Use <span><a href=".././api/js_of_ocaml/Js_of_ocaml/Js/Unsafe/#val-fun_call">Js_of_ocaml.Js.Unsafe.fun_call</a></span> for functions where <span class="teletype">this</span> doesn't matter:
</p><pre class=""><code class="language-ocaml translatable">(* Equivalent to: decodeURI(s) *)
let decodeURI (s : Js.js_string Js.t) : Js.js_string Js.t =
  Js.Unsafe.fun_call
    (Js.Unsafe.js_expr &quot;decodeURI&quot;)
    [| Js.Unsafe.inject s |]

(* Equivalent to: parseInt(s, 10) *)
let parseInt (s : Js.js_string Js.t) : int =
  Js.Unsafe.fun_call
    (Js.Unsafe.js_expr &quot;parseInt&quot;)
    [| Js.Unsafe.inject s; Js.Unsafe.inject 10 |]</code></pre><h3> Methods with <span class="teletype">meth_call</span></h3><p>Use <span><a href=".././api/js_of_ocaml/Js_of_ocaml/Js/Unsafe/#val-meth_call">Js_of_ocaml.Js.Unsafe.meth_call</a></span> to call a method on an object (<span class="teletype">this</span> is
bound to the object):
</p><pre class=""><code class="language-ocaml translatable">(* Equivalent to: arr.slice(1, 3) *)
let slice arr start stop =
  Js.Unsafe.meth_call arr &quot;slice&quot;
    [| Js.Unsafe.inject start; Js.Unsafe.inject stop |]</code></pre><h3> Functions with explicit <span class="teletype">this</span> binding</h3><p>Use <span><a href=".././api/js_of_ocaml/Js_of_ocaml/Js/Unsafe/#val-call">Js_of_ocaml.Js.Unsafe.call</a></span> when you need to explicitly set <span class="teletype">this</span>:
</p><pre class=""><code class="language-ocaml translatable">(* Equivalent to: func.call(thisArg, arg1, arg2) *)
let result =
  Js.Unsafe.call func thisArg [| Js.Unsafe.inject arg1; Js.Unsafe.inject arg2 |]</code></pre><p>See the <span><a href=".././api/js_of_ocaml/Js_of_ocaml/Js/Unsafe/#module-Unsafe">Js_of_ocaml.Js.Unsafe</a></span> module
API for more details.
</p><h2 id="callbacks"> Passing OCaml functions to JavaScript <a class="backref" href="#callbacks">&#182;</a></h2><p>When JavaScript code needs to call back into OCaml (e.g., event handlers,
callbacks for async operations), you must wrap OCaml functions appropriately.
</p><h3> Basic callbacks with <span><a href=".././api/js_of_ocaml/Js_of_ocaml/Js/#val-wrap_callback">Js_of_ocaml.Js.wrap_callback</a></span></h3><p>Use <span><a href=".././api/js_of_ocaml/Js_of_ocaml/Js/#val-wrap_callback">Js_of_ocaml.Js.wrap_callback</a></span> to wrap an OCaml function for JavaScript:
</p><pre class=""><code class="language-ocaml translatable">(* setTimeout example *)
let set_timeout f ms =
  Js.Unsafe.global##setTimeout
    (Js.wrap_callback f)
    (Js.float ms)

let () = set_timeout (fun () -&gt; print_endline &quot;Hello!&quot;) 1000.</code></pre><p><span><a href=".././api/js_of_ocaml/Js_of_ocaml/Js/#val-wrap_callback">Js_of_ocaml.Js.wrap_callback</a></span> handles partial application correctly: if JavaScript
calls the function with fewer arguments than expected, the result is a
partially applied function.
</p><h3> Callbacks with <span class="teletype">this</span> binding</h3><p>Use <span><a href=".././api/js_of_ocaml/Js_of_ocaml/Js/#val-wrap_meth_callback">Js_of_ocaml.Js.wrap_meth_callback</a></span> when the callback needs access to <span class="teletype">this</span>:
</p><pre class=""><code class="language-ocaml translatable">(* The first parameter receives the 'this' value *)
let callback = Js.wrap_meth_callback (fun this event -&gt;
  let target : Dom_html.element Js.t = this in
  (* ... handle event ... *)
  Js._true)</code></pre><h3> Strict arity callbacks</h3><p>For performance-critical code, or when you don't need partial application
support, use <span><a href=".././api/js_of_ocaml/Js_of_ocaml/Js/Unsafe/#val-callback">Js_of_ocaml.Js.Unsafe.callback</a></span> or <span><a href=".././api/js_of_ocaml/Js_of_ocaml/Js/Unsafe/#val-callback_with_arity">Js_of_ocaml.Js.Unsafe.callback_with_arity</a></span>:
</p><pre class=""><code class="language-ocaml translatable">(* Strict callback - missing args become undefined, extra args are lost *)
let strict_cb = Js.Unsafe.callback (fun x y -&gt; x + y)

(* Explicit arity - ensures exactly 2 arguments *)
let arity_cb = Js.Unsafe.callback_with_arity 2 (fun x y -&gt; x + y)</code></pre><h3> DOM event handlers</h3><p>For DOM events, use <span><a href=".././api/js_of_ocaml/Js_of_ocaml/Dom/#val-handler">Js_of_ocaml.Dom.handler</a></span> or <span><a href=".././api/js_of_ocaml/Js_of_ocaml/Dom_html/#val-handler">Js_of_ocaml.Dom_html.handler</a></span> which
automatically wraps the function and handles the return value (returning
<span><a href=".././api/js_of_ocaml/Js_of_ocaml/Js/#val-_false">Js_of_ocaml.Js._false</a></span> prevents the default action):
</p><pre class=""><code class="language-ocaml translatable">let button = Dom_html.getElementById &quot;myButton&quot;

let handler = Dom_html.handler (fun event -&gt;
  Dom_html.window##alert (Js.string &quot;Clicked!&quot;);
  Js._true (* return false to prevent default *))

button##.onclick := handler</code></pre><p>For handlers that need access to <span class="teletype">this</span>, use <span><a href=".././api/js_of_ocaml/Js_of_ocaml/Dom/#val-full_handler">Js_of_ocaml.Dom.full_handler</a></span>:
</p><pre class=""><code class="language-ocaml translatable">let handler = Dom.full_handler (fun this event -&gt;
  let element : Dom_html.element Js.t = this in
  (* ... *)
  Js._true)</code></pre><h3> Callbacks with variable arguments</h3><p>Use <span><a href=".././api/js_of_ocaml/Js_of_ocaml/Js/Unsafe/#val-callback_with_arguments">Js_of_ocaml.Js.Unsafe.callback_with_arguments</a></span> when the callback receives a
variable number of arguments:
</p><pre class=""><code class="language-ocaml translatable">let varargs_cb = Js.Unsafe.callback_with_arguments (fun args -&gt;
  let len = args##.length in
  Printf.printf &quot;Called with %d arguments\n&quot; len)</code></pre><h2 id="constructors"> Using a JS constructor <a class="backref" href="#constructors">&#182;</a></h2><p>To call a JavaScript constructor (i.e., <span class="teletype">new F(...)</span>), first obtain the
constructor (i.e. from the global object), then use <span class="teletype">new%js</span> to instantiate it.
</p><h3> Basic usage</h3><pre class=""><code class="language-ocaml translatable">(* In .ml: get the constructor *)
let dateConstr : (int -&gt; int -&gt; int -&gt; Js.date Js.t) Js.constr =
  Js.Unsafe.global##._Date

(* Create an instance using new%js *)
let my_date = new%js dateConstr 2024 0 15</code></pre><p>This is equivalent to:
</p><pre class="manually-translated"><code class="language-javascript">new Date(2024, 0, 15)</code></pre><h3> Handling overloaded constructors</h3><p>JavaScript constructors often accept different argument types. Since OCaml
requires fixed types, define multiple bindings for each signature:
</p><pre class=""><code class="language-ocaml translatable">(* In .mli *)
val dateConstr : (int -&gt; int -&gt; int -&gt; Js.date Js.t) Js.constr
val dateConstr_fromValue : (int -&gt; Js.date Js.t) Js.constr
val dateConstr_fromString : (Js.js_string Js.t -&gt; Js.date Js.t) Js.constr

(* In .ml - all point to the same JS constructor *)
let dateConstr = Js.Unsafe.global##._Date
let dateConstr_fromValue = Js.Unsafe.global##._Date
let dateConstr_fromString = Js.Unsafe.global##._Date</code></pre><h3> Constructors from nested objects</h3><p>For constructors not on the global object, bind them first:
</p><pre class=""><code class="language-ocaml translatable">let workerConstr : (Js.js_string Js.t -&gt; worker Js.t) Js.constr =
  Js.Unsafe.global##._Worker

(* For nested: someLib.SomeClass *)
let someClass = (Js.Unsafe.js_expr &quot;someLib&quot;)##._SomeClass in
new%js someClass arg1 arg2</code></pre><h2 id="object-literals"> Constructing JS objects manually <a class="backref" href="#object-literals">&#182;</a></h2><p>To construct a JS object without calling a constructor, use the
<span><a href=".././manual/Ppx">Ppx</a></span> syntax extension (recommended) or
<span><a href=".././api/js_of_ocaml/Js_of_ocaml/Js/Unsafe/#val-obj">Js_of_ocaml.Js.Unsafe.obj</a></span>.
</p><h3> Using the PPX syntax (recommended)</h3><pre class=""><code class="language-ocaml translatable">let options = object%js
  val x = 3 (* read-only prop *)
  val mutable y = 4 (* read/write prop *)
  method greet name = Js.string (&quot;Hello &quot; ^ Js.to_string name)
end</code></pre><p>This produces the equivalent of:
</p><pre class="manually-translated"><code class="language-javascript">{ x: 3, y: 4, greet: function(name) { return &quot;Hello &quot; + name; } }</code></pre><p>See the <span><a href=".././manual/Ppx">Ppx documentation</a></span> for more details.
</p><h3> Using <span><a href=".././api/js_of_ocaml/Js_of_ocaml/Js/Unsafe/#val-obj">Js_of_ocaml.Js.Unsafe.obj</a></span></h3><p>For dynamic object construction, use <span><a href=".././api/js_of_ocaml/Js_of_ocaml/Js/Unsafe/#val-obj">Js_of_ocaml.Js.Unsafe.obj</a></span> with an array of
key-value pairs:
</p><pre class=""><code class="language-ocaml translatable">let options : &lt; x: int Js.prop; y: int Js.prop &gt; Js.t =
  Js.Unsafe.obj [|
    (&quot;x&quot;, Js.Unsafe.inject 3);
    (&quot;y&quot;, Js.Unsafe.inject 4);
  |]</code></pre><p>A common pattern is to create an empty object and set properties afterwards.
This is useful when calling JavaScript functions that expect an options object
with optional fields. Use <span class="teletype">writeonly_prop</span> for the type to prevent reading
unset properties (which would return <span class="teletype">undefined</span>):
</p><pre class=""><code class="language-ocaml translatable">class type myOptions = object
  method timeout : int Js.writeonly_prop
  method retry : bool Js.t Js.writeonly_prop
end

let call_with_options () =
  let options : myOptions Js.t = Js.Unsafe.obj [||] in
  options##.timeout := 5000;
  options##.retry := Js._true;
  some_js_function options</code></pre><h2 id="feature-detection"> Check availability of methods and properties <a class="backref" href="#feature-detection">&#182;</a></h2><p>JavaScript APIs vary across browsers and environments. A method or property
may exist in one browser but not another, or may have been added in a recent
version. Use <span><a href=".././api/js_of_ocaml/Js_of_ocaml/Js/Optdef/#module-Optdef">Js_of_ocaml.Js.Optdef</a></span> to safely check for and access optional members.
</p><h3> Checking if a member exists</h3><pre class=""><code class="language-ocaml translatable">let has_method obj = Js.Optdef.test (Js.Unsafe.coerce obj)##.someMethod
let has_prop obj = Js.Optdef.test (Js.Unsafe.coerce obj)##.someProp</code></pre><h3> Safely accessing optional members</h3><p>Use <span><a href=".././api/js_of_ocaml/Js_of_ocaml/Js/Optdef/#val-to_option">Js_of_ocaml.Js.Optdef.to_option</a></span> to convert to an OCaml option:
</p><pre class=""><code class="language-ocaml translatable">let get_optional_method obj =
  Js.Optdef.to_option (Js.Unsafe.coerce obj)##.someMethod

let () =
  match get_optional_method my_obj with
  | Some f -&gt; (* use the method *)
  | None -&gt; (* fallback behavior *)</code></pre><p>Use <span><a href=".././api/js_of_ocaml/Js_of_ocaml/Js/Optdef/#val-case">Js_of_ocaml.Js.Optdef.case</a></span> for inline handling:
</p><pre class=""><code class="language-ocaml translatable">let result =
  Js.Optdef.case (Js.Unsafe.coerce obj)##.optionalMethod
    (fun () -&gt; (* not defined, use fallback *) default_value)
    (fun m -&gt; (* defined, use it *) m arg1 arg2)</code></pre><h3> Example: feature detection</h3><pre class=""><code class="language-ocaml translatable">let supports_fetch () =
  Js.Optdef.test Js.Unsafe.global##.fetch

let supports_local_storage () =
  Js.Optdef.test Js.Unsafe.global##.localStorage</code></pre><h2 id="union-types"> Object property with multiple types <a class="backref" href="#union-types">&#182;</a></h2><p>JavaScript APIs often use union types where a property can hold values of
different types (e.g., <span class="teletype">string | Node</span> or <span class="teletype">number | null</span>). Since OCaml
requires a single type, use an opaque type with runtime type checking.
</p><h3> Using <span class="teletype">instanceof</span> for object types</h3><p>Use <span><a href=".././api/js_of_ocaml/Js_of_ocaml/Js/#val-instanceof">Js_of_ocaml.Js.instanceof</a></span> to distinguish between different object types
(e.g., DOM nodes, custom classes). Define an opaque type and cast functions:
</p><pre class=""><code class="language-ocaml translatable">(* Opaque type representing the union: Element | Text *)
type element_or_text

class type container = object
  method child : element_or_text Js.t Js.prop
end

(* Cast functions using instanceof *)
let as_element (x : element_or_text Js.t) : Dom.element Js.t Js.opt =
  if Js.instanceof x (Js.Unsafe.global##._Element)
  then Js.some (Js.Unsafe.coerce x)
  else Js.null

let as_text (x : element_or_text Js.t) : Dom.text Js.t Js.opt =
  if Js.instanceof x (Js.Unsafe.global##._Text)
  then Js.some (Js.Unsafe.coerce x)
  else Js.null

(* Usage *)
let handle_child (container : container Js.t) =
  let child = container##.child in
  Js.Opt.case (as_element child)
    (fun () -&gt;
      Js.Opt.case (as_text child)
        (fun () -&gt; failwith &quot;unexpected type&quot;)
        (fun text -&gt; (* handle text node *)))
    (fun elem -&gt; (* handle element *))</code></pre><h3> Using <span class="teletype">typeof</span> for primitive types</h3><p>For primitive types (string, number, boolean), use <span><a href=".././api/js_of_ocaml/Js_of_ocaml/Js/#val-typeof">Js_of_ocaml.Js.typeof</a></span>:
</p><pre class=""><code class="language-ocaml translatable">type string_or_number

let as_string (x : string_or_number Js.t) : Js.js_string Js.t Js.opt =
  if Js.typeof x = Js.string &quot;string&quot;
  then Js.some (Js.Unsafe.coerce x)
  else Js.null

let as_number (x : string_or_number Js.t) : Js.number Js.t Js.opt =
  if Js.typeof x = Js.string &quot;number&quot;
  then Js.some (Js.Unsafe.coerce x)
  else Js.null</code></pre><h3> Converting to OCaml variants</h3><p>For cleaner OCaml code, convert the union to a variant:
</p><pre class=""><code class="language-ocaml translatable">type child =
  | Element of Dom.element Js.t
  | Text of Dom.text Js.t

let classify_child (x : element_or_text Js.t) : child =
  if Js.instanceof x (Js.Unsafe.global##._Element)
  then Element (Js.Unsafe.coerce x)
  else Text (Js.Unsafe.coerce x)

(* Now use pattern matching *)
let handle container =
  match classify_child container##.child with
  | Element e -&gt; (* work with element *)
  | Text t -&gt; (* work with text node *)</code></pre><h2 id="runtime-values"> Accessing JavaScript runtime values <a class="backref" href="#runtime-values">&#182;</a></h2><p>The <span><a href=".././api/js_of_ocaml/Jsoo_runtime/Js/#val-runtime_value">Jsoo_runtime.Js.runtime_value</a></span> function allows direct access to JavaScript
values provided by the runtime (declared with <span class="teletype">//Provides:</span> directives in
JavaScript files).
</p><pre class=""><code class="language-ocaml translatable">external runtime_value : string -&gt; 'a = &quot;caml_jsoo_runtime_value&quot;</code></pre><p>This function is useful when you need to access JavaScript values defined by an external javascript package.
and you don't want to polute the global object.
</p><p><strong>Important</strong>: The argument must be a <strong>string literal</strong>, not a variable.
The compiler will reject non-literal arguments.
</p><h3> Example</h3><p>Given a JavaScript file <span class="teletype">custom.js</span> linked with your program:
</p><pre class="manually-translated"><code class="language-javascript">//Provides: process
var process = &quot;my process value&quot;;

//Provides: myConfig
var myConfig = { debug: true, version: 42 };</code></pre><p>You can access these values from OCaml:
</p><pre class=""><code class="language-ocaml translatable">let process_str : Js.js_string Js.t = Jsoo_runtime.Js.runtime_value &quot;process&quot;

let config : &lt; debug : bool Js.t Js.prop; version : int Js.prop &gt; Js.t =
  Jsoo_runtime.Js.runtime_value &quot;myConfig&quot;

let () =
  print_endline (Js.to_string process_str);
  if Js.to_bool config##.debug then
    Printf.printf &quot;Version: %d\n&quot; config##.version</code></pre></article></div></div></body></html>
